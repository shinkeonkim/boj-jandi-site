{% extends "base.html" %}

{% block title %}BOJ Jandi - {{ handle }}{% endblock %}

{% block container_style %}style="max-width: 1400px;"{% endblock %}

{% block content %}
<div class="glass-card">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem;">
        <a href="/" style="color: var(--primary-color); text-decoration: none; font-size: 0.9rem;">&larr; Îã§Ïãú Í≤ÄÏÉâ</a>
        <h2 style="margin: 0; color: var(--secondary-color);">@{{ handle }}</h2>
        <div id="status-badge" style="font-size: 0.8rem; opacity: 0.6;">Îç∞Ïù¥ÌÑ∞ ÌôïÏù∏ Ï§ë...</div>
    </div>

    <div id="loader" class="loader" style="display: block;"></div>
    
    <div id="canvas-container" style="display: none;">
        <canvas id="grassCanvas"></canvas>
    </div>
    
    <p id="error-msg" style="color: #ff5252; display: none;"></p>
</div>

<div id="tooltip"></div>
{% endblock %}

{% block scripts %}
<script>
    const handle = "{{ handle }}";
    const canvas = document.getElementById('grassCanvas');
    const ctx = canvas.getContext('2d');
    const loader = document.getElementById('loader');
    const canvasContainer = document.getElementById('canvas-container');
    const statusBadge = document.getElementById('status-badge');
    const errorMsg = document.getElementById('error-msg');
    const tooltip = document.getElementById('tooltip');

    const MIN_ID = 1000;
    const MAX_ID = 40000;
    const CELL_SIZE = 10;
    const CELL_GAP = 2;
    const COLOR_EMPTY = 'rgba(255, 255, 255, 0.05)';
    const COLOR_SOLVED = '#03dac6';

    let solvedSet = new Set();
    let COLUMNS = 100;
    let ROWS = 0;
    let pollInterval = null;

    async function fetchData() {
        try {
            const response = await fetch(`/api/grass/${handle}`);
            if (!response.ok) throw new Error('Ï†ïÎ≥¥Î•º Í∞ÄÏ†∏Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
            
            const data = await response.json();
            
            if (data.status === 'pending') {
                statusBadge.innerText = 'Í∞±Ïã† Ï§ë...';
                // If we have some old pids, we could show them, but for now let's wait
                // Or show partial if available? 
                if (data.pids && data.pids.length > 0) {
                        solvedSet = new Set(data.pids);
                        loader.style.display = 'none';
                        canvasContainer.style.display = 'block';
                        initCanvas();
                        statusBadge.innerText = 'Í∞±Ïã† Ï§ë... (Ïù¥Ï†Ñ Îç∞Ïù¥ÌÑ∞ ÌëúÏãú)';
                }
                
                if (!pollInterval) {
                    pollInterval = setTimeout(fetchData, 2000); // Poll every 2 seconds
                } else {
                    pollInterval = setTimeout(fetchData, 2000);
                }
            } else if (data.status === 'completed') {
                solvedSet = new Set(data.pids);
                
                loader.style.display = 'none';
                canvasContainer.style.display = 'block';
                statusBadge.innerText = 'ÏôÑÎ£åÎê®';
                
                initCanvas();
                if (pollInterval) clearTimeout(pollInterval);
            } else if (data.status === 'error') {
                    loader.style.display = 'none';
                    errorMsg.innerText = "Îç∞Ïù¥ÌÑ∞ Í∞±Ïã† Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.";
                    errorMsg.style.display = 'block';
                    statusBadge.innerText = 'Ïò§Î•ò';
                    if (pollInterval) clearTimeout(pollInterval);
            }

        } catch (err) {
            // Network error, retry?
            console.error(err);
            if (!pollInterval) pollInterval = setTimeout(fetchData, 3000);
        }
    }

    function initCanvas() {
        const totalItems = MAX_ID - MIN_ID + 1;
        // Adjust for potential padding/margin issues
        const availableWidth = canvasContainer.clientWidth - 20; 
        
        // Calculate max possible columns that fit
        let maxPossibleCols = Math.floor(availableWidth / (CELL_SIZE + CELL_GAP));
        
        // Snap to nearest lower 10
        // e.g., 95 -> 90, 82 -> 80
        let newCols = Math.floor(maxPossibleCols / 10) * 10;
        
        // Max limit 100
        if (newCols > 100) newCols = 100;
        
        // Min limit to avoid too narrow (optional, but good for safety)
        if (newCols < 10) newCols = 10;
        
        COLUMNS = newCols;

        ROWS = Math.ceil(totalItems / COLUMNS);
        canvas.width = COLUMNS * (CELL_SIZE + CELL_GAP);
        canvas.height = ROWS * (CELL_SIZE + CELL_GAP);

        draw();
    }

    function draw() {
        const totalItems = MAX_ID - MIN_ID + 1;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (let i = 0; i < totalItems; i++) {
            const pid = MIN_ID + i;
            const row = Math.floor(i / COLUMNS);
            const col = i % COLUMNS;

            const x = col * (CELL_SIZE + CELL_GAP);
            const y = row * (CELL_SIZE + CELL_GAP);

            ctx.fillStyle = solvedSet.has(pid) ? COLOR_SOLVED : COLOR_EMPTY;
            ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
        }
    }

    function getProblemFromCoords(e) {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (canvas.width / rect.width);
        const y = (e.clientY - rect.top) * (canvas.height / rect.height);

        const col = Math.floor(x / (CELL_SIZE + CELL_GAP));
        const row = Math.floor(y / (CELL_SIZE + CELL_GAP));

        if (col < 0 || col >= COLUMNS || row < 0 || row >= ROWS) return null;

        const index = row * COLUMNS + col;
        const pid = MIN_ID + index;

        return pid > MAX_ID ? null : pid;
    }

    canvas.addEventListener('mousemove', (e) => {
        const pid = getProblemFromCoords(e);
        if (pid) {
            tooltip.style.display = 'block';
            tooltip.style.left = (e.pageX + 15) + 'px';
            tooltip.style.top = (e.pageY + 15) + 'px';
            tooltip.innerHTML = `<strong>Problem ${pid}</strong><br>${solvedSet.has(pid) ? 'Solved üü¢' : 'Not Solved yet'}`;
            canvas.style.cursor = 'pointer';
        } else {
            tooltip.style.display = 'none';
            canvas.style.cursor = 'default';
        }
    });

    canvas.addEventListener('mouseleave', () => {
        tooltip.style.display = 'none';
    });

    canvas.addEventListener('click', (e) => {
        const pid = getProblemFromCoords(e);
        if (pid) {
            window.open(`https://www.acmicpc.net/problem/${pid}`, '_blank');
        }
    });

    window.addEventListener('resize', initCanvas);
    fetchData();
</script>
{% endblock %}
