{% extends "base.html" %}

{% block title %}BOJ Jandi - {{ handle }}{% endblock %}

{% block container_style %}style="max-width: 1400px;"{% endblock %}

{% block content %}
<div class="glass-card">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 2rem;">
        <a href="/" style="color: var(--primary-color); text-decoration: none; font-size: 0.9rem;">&larr; ë‹¤ì‹œ ê²€ìƒ‰</a>
        <h2 style="margin: 0; color: var(--secondary-color);">@{{ handle }}</h2>
        <div id="status-badge" style="font-size: 0.8rem; opacity: 0.6;">ë°ì´í„° í™•ì¸ ì¤‘...</div>
    </div>

    <div id="loader" class="loader" style="display: block;"></div>
    
    <div class="controls-bar">
        <label class="toggle-switch">
            <input type="checkbox" id="show-tier-checkbox" class="toggle-input">
            <div class="toggle-slider"></div>
            <span class="toggle-label">í‹°ì–´ ë³´ê¸°</span>
        </label>
    </div>

    <div id="canvas-container" style="display: none;">
        <canvas id="grassCanvas"></canvas>
    </div>
    
    <p id="error-msg" style="color: #ff5252; display: none;"></p>
</div>

<div id="tooltip"></div>
{% endblock %}

{% block scripts %}
<script>
    const handle = "{{ handle }}";
    const canvas = document.getElementById('grassCanvas');
    const ctx = canvas.getContext('2d');
    const loader = document.getElementById('loader');
    const canvasContainer = document.getElementById('canvas-container');
    const statusBadge = document.getElementById('status-badge');
    const errorMsg = document.getElementById('error-msg');
    const tooltip = document.getElementById('tooltip');
    const showTierCheckbox = document.getElementById('show-tier-checkbox');

    const MIN_ID = 1000;
    const MAX_ID = 40000;
    const CELL_SIZE = 10;
    const CELL_GAP = 2;
    const COLOR_EMPTY = 'rgba(255, 255, 255, 0.05)';
    const COLOR_SOLVED = '#03dac6';
    
    const TIER_COLORS = {
        0: '#424242', // Unrated
        1: '#ad5600', 2: '#ad5600', 3: '#ad5600', 4: '#ad5600', 5: '#ad5600', // Bronze
        6: '#435f7a', 7: '#435f7a', 8: '#435f7a', 9: '#435f7a', 10: '#435f7a', // Silver
        11: '#ec9a00', 12: '#ec9a00', 13: '#ec9a00', 14: '#ec9a00', 15: '#ec9a00', // Gold
        16: '#27e2a4', 17: '#27e2a4', 18: '#27e2a4', 19: '#27e2a4', 20: '#27e2a4', // Platinum
        21: '#00b4fc', 22: '#00b4fc', 23: '#00b4fc', 24: '#00b4fc', 25: '#00b4fc', // Diamond
        26: '#ff0062', 27: '#ff0062', 28: '#ff0062', 29: '#ff0062', 30: '#ff0062', // Ruby
    };

    let solvedSet = new Set();
    let solvedTiers = {}; // pid -> tier
    let solvedTitles = {}; // pid -> title
    let COLUMNS = 100;
    let ROWS = 0;
    let pollInterval = null;

    showTierCheckbox.addEventListener('change', draw);

    async function fetchData() {
        try {
            const response = await fetch(`/api/grass/${handle}`);
            if (!response.ok) throw new Error('ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            
            const data = await response.json();
            
            if (data.status === 'pending') {
                statusBadge.innerText = 'ê°±ì‹  ì¤‘...';
                
                if (data.pids && data.pids.length > 0) {
                        solvedSet = new Set(data.pids);
                        // Start fetching details in background
                        fetchDetailsChunked(data.pids);
                        
                        loader.style.display = 'none';
                        canvasContainer.style.display = 'block';
                        initCanvas();
                        statusBadge.innerText = 'ê°±ì‹  ì¤‘... (ì´ì „ ë°ì´í„° í‘œì‹œ)';
                }
                
                if (!pollInterval) {
                    pollInterval = setTimeout(fetchData, 2000); 
                } else {
                    pollInterval = setTimeout(fetchData, 2000);
                }
            } else if (data.status === 'completed') {
                solvedSet = new Set(data.pids);
                
                loader.style.display = 'none';
                canvasContainer.style.display = 'block';
                statusBadge.innerText = 'ì™„ë£Œë¨';
                
                initCanvas();
                fetchDetailsChunked(data.pids); // Fetch details now
                
                if (pollInterval) clearTimeout(pollInterval);
            } else if (data.status === 'not_found') {
                    loader.style.display = 'none';
                    errorMsg.innerText = "ì°¾ì„ ìˆ˜ ì—†ëŠ” ìœ ì €ì…ë‹ˆë‹¤.";
                    errorMsg.style.display = 'block';
                    statusBadge.innerText = 'ìœ ì € ì—†ìŒ';
                    if (pollInterval) clearTimeout(pollInterval);
            } else if (data.status === 'error') {
                    loader.style.display = 'none';
                    errorMsg.innerText = "ë°ì´í„° ê°±ì‹  ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.";
                    errorMsg.style.display = 'block';
                    statusBadge.innerText = 'ì˜¤ë¥˜';
                    if (pollInterval) clearTimeout(pollInterval);
            }

        } catch (err) {
            console.error(err);
            if (!pollInterval) pollInterval = setTimeout(fetchData, 3000);
        }
    }
    
    async function fetchDetailsChunked(pids) {
        // Only fetch if we have PIDs
        if (!pids || pids.length === 0) return;
        
        const CHUNK_SIZE = 200;
        for (let i = 0; i < pids.length; i += CHUNK_SIZE) {
            const chunk = pids.slice(i, i + CHUNK_SIZE);
            try {
                const response = await fetch('/api/grass/details', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ pids: chunk })
                });
                
                if (response.ok) {
                    const details = await response.json();
                    // Merge
                    for (const [pid, info] of Object.entries(details)) {
                        solvedTiers[pid] = info.tier;
                        solvedTitles[pid] = info.title;
                    }
                    // Redraw to show new tiers if checkbox is checked
                    if (showTierCheckbox.checked) {
                        draw();
                    }
                }
            } catch (e) {
                console.error("Failed to fetch details chunk", e);
            }
        }
    }

    function initCanvas() {
        const totalItems = MAX_ID - MIN_ID + 1;
        const availableWidth = canvasContainer.clientWidth - 20; 
        
        let maxPossibleCols = Math.floor(availableWidth / (CELL_SIZE + CELL_GAP));
        let newCols = Math.floor(maxPossibleCols / 10) * 10;
        
        if (newCols > 100) newCols = 100;
        if (newCols < 10) newCols = 10;
        
        COLUMNS = newCols;

        ROWS = Math.ceil(totalItems / COLUMNS);
        canvas.width = COLUMNS * (CELL_SIZE + CELL_GAP);
        canvas.height = ROWS * (CELL_SIZE + CELL_GAP);

        draw();
    }

    function draw() {
        const totalItems = MAX_ID - MIN_ID + 1;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const showTier = showTierCheckbox.checked;

        for (let i = 0; i < totalItems; i++) {
            const pid = MIN_ID + i;
            const row = Math.floor(i / COLUMNS);
            const col = i % COLUMNS;

            const x = col * (CELL_SIZE + CELL_GAP);
            const y = row * (CELL_SIZE + CELL_GAP);
            
            let color = COLOR_EMPTY;
            if (solvedSet.has(pid)) {
                if (showTier) {
                    const tier = solvedTiers[pid] || 0;
                    color = TIER_COLORS[tier] || TIER_COLORS[0];
                } else {
                    color = COLOR_SOLVED;
                }
            }

            ctx.fillStyle = color;
            ctx.fillRect(x, y, CELL_SIZE, CELL_SIZE);
        }
    }

    function getProblemFromCoords(e) {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (canvas.width / rect.width);
        const y = (e.clientY - rect.top) * (canvas.height / rect.height);

        const col = Math.floor(x / (CELL_SIZE + CELL_GAP));
        const row = Math.floor(y / (CELL_SIZE + CELL_GAP));

        if (col < 0 || col >= COLUMNS || row < 0 || row >= ROWS) return null;

        const index = row * COLUMNS + col;
        const pid = MIN_ID + index;

        return pid > MAX_ID ? null : pid;
    }

    const TIER_NAMES = ["Unrated", "Bronze", "Silver", "Gold", "Platinum", "Diamond", "Ruby"];
    const ROMAN = ["", "I", "II", "III", "IV", "V"];

    function getTierInfo(tier) {
        if (!tier || tier === 0) return { name: "Unrated", color: TIER_COLORS[0] };
        
        let index = Math.ceil(tier / 5);
        if (index >= TIER_NAMES.length) index = TIER_NAMES.length - 1;
        
        const name = TIER_NAMES[index];
        const level = 6 - ((tier % 5) || 5); 
        const roman = ROMAN[level] || "";
        
        return { name: `${name} ${roman}`.trim(), color: TIER_COLORS[tier] };
    }

    let selectedPid = null;

    function updateTooltip(pid, x, y) {
            tooltip.style.display = 'block';
            tooltip.style.left = px = x + 15 + 'px';
            tooltip.style.top = py = y + 15 + 'px';

            let extra = "";
            const title = solvedTitles[pid] ? ` ${solvedTitles[pid]}` : "";
            const header = `<strong>${pid}ë²ˆ:${title}</strong>`;
            
            // Tier Info (Always shown if showTier is checked)
            if (showTierCheckbox.checked) {
                const tier = solvedTiers[pid] || 0;
                const info = getTierInfo(tier);
                extra += `<br><span style="color: ${info.color}; font-weight: bold;">${info.name}</span>`;
            }

            if (solvedSet.has(pid)) {
                 extra += '<br>Solved ğŸŸ¢';
            } else {
                extra += '<br>Not Solved yet';
            }
            
            tooltip.innerHTML = `${header}${extra}`;
            canvas.style.cursor = 'pointer';
    }

    canvas.addEventListener('mousemove', (e) => {
        const pid = getProblemFromCoords(e);
        if (pid) {
            updateTooltip(pid, e.pageX, e.pageY);
        } else {
            tooltip.style.display = 'none';
            canvas.style.cursor = 'default';
        }
    });

    canvas.addEventListener('mouseleave', () => {
        tooltip.style.display = 'none';
        selectedPid = null; // Reset selection on leave
    });

    canvas.addEventListener('click', (e) => {
        const pid = getProblemFromCoords(e);
        if (!pid) {
             selectedPid = null;
             tooltip.style.display = 'none';
             return;
        }

        const isTouch = (e.pointerType === 'touch') || (navigator.maxTouchPoints > 0 && /Android|iPhone|iPad|iPod/i.test(navigator.userAgent));

        if (isTouch) {
            if (selectedPid === pid) {
                 window.open(`https://www.acmicpc.net/problem/${pid}`, '_blank');
                 selectedPid = null;
                 tooltip.style.display = 'none';
            } else {
                selectedPid = pid;
                updateTooltip(pid, e.pageX, e.pageY);
            }
        } else {
            window.open(`https://www.acmicpc.net/problem/${pid}`, '_blank');
        }
    });

    window.addEventListener('resize', initCanvas);
    fetchData();
</script>
{% endblock %}
